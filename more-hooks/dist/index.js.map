{"version":3,"file":"index.js","sources":["../src/createDefinedContext.ts","../src/useOnMount.ts","../src/useAsync.ts"],"sourcesContent":["import React from \"react\";\n\n/**\n * A React Context Provider that can only be used when there are values present. Your data can't be undefined. In other words, no validation required.\n *\n * @return   {[hook, React.Context]}\n */\n\nconst createDefinedContext = <A extends unknown | null>() => {\n  const context = React.createContext<A | undefined>(undefined);\n\n  const useDefinedContext = () => {\n    const c = React.useContext(context);\n    if (c === undefined) {\n      throw new Error(\n        \"Context value is undefined. useDefined must be inside a ContextProvider with a defined value.\"\n      );\n    }\n    return c;\n  };\n\n  return [useDefinedContext, context.Provider] as const;\n};\n\nexport default createDefinedContext;\n","import { useEffect } from \"react\";\n\n/**\n * A tiny hook that runs only during your components first render lifecycle. Remeber onComponentDidMount?.\n *\n * @param    {Function} methods\n *           this rest parameter can take any amount of input methods\n *\n * @return   {void}\n *\n * @example\n * const Component = () => {\n *   const [text, setText] = useState(\"\");\n *\n *   const fetch = async () => {\n *     const response = await myApi();\n *     setText(response);\n *   };\n *\n *   useOnMount(fetch);\n *\n *   return (\n *     <>\n *       {text && <p>Response text: {text}</p>}\n *       {!text && <Alert>Just mounted anew, hang on...</Alert>}\n *     </>\n *   );\n * };\n */\n\nconst useOnMount = (...methods: (() => unknown)[]) =>\n  useEffect(() => {\n    for (const f of methods) f();\n  }, []);\n\nexport default useOnMount;\n","import { useCallback, useState } from \"react\";\nimport useOnMount from \"./useOnMount\";\n\n/**\n * A hook designed to simplify the handling of a asynchronous calls.\n *\n * @param    {() => Promise<T>} method\n *           the asynchronous method that this hook will call\n \n * @param    {UseAsyncOptions | undefined} options\n *\n * @return   {Object}\n *           response data, status information and callback method\n *\n * @example\n * const Component = () => {\n *   const { response, pending, success, error, call } = useAsync(fetchResource);\n *   return (\n *     <>\n *       {pending && <LoadingSpinner />}\n *       {error && <MyError error={error} />}\n *       {success && <SuccessMessage />}\n *       {!pending && response && <MyData data={response} />}\n *       <Button onClick={() => call()}>Fetch resource</Button>\n *     </>\n *   );\n * };\n */\n\nexport type UseAsyncResponse<R, A extends unknown[]> = {\n  response: R | undefined;\n  pending: boolean;\n  success: boolean;\n  error: unknown | null;\n  hasBeenCalled: boolean;\n  call: UseAsyncMethod<R, A>;\n};\n\nexport type UseAsyncMethod<R, A extends unknown[]> = {\n  (...args: A): Promise<R>;\n};\n\nexport type UseAsyncOptions<A extends unknown[]> = { immediate: A };\n\nconst useAsync = <R, A extends unknown[]>(\n  method: UseAsyncMethod<R, A>,\n  options?: UseAsyncOptions<A>\n): UseAsyncResponse<R, A> => {\n  const [response, setResponse] = useState<R>();\n  const [pending, setPending] = useState<boolean>(false);\n  const [success, setSuccess] = useState<boolean>(false);\n  const [error, setError] = useState<unknown | null>(null);\n  const [hasBeenCalled, setHasBeenCalled] = useState<boolean>(false);\n\n  const call = useCallback(async (...args: Parameters<typeof method>) => {\n    setHasBeenCalled(true);\n    setPending(true);\n    setError(null);\n\n    try {\n      const response = await method(...args);\n      setResponse(response);\n      setSuccess(true);\n      return response;\n    } catch (error) {\n      setError(error);\n      setSuccess(false);\n      throw error;\n    } finally {\n      setPending(false);\n    }\n  }, []);\n\n  useOnMount(() => {\n    if (options?.immediate) {\n      call(...options?.immediate);\n    }\n  });\n\n  return { response, pending, success, error, call, hasBeenCalled };\n};\n\nexport default useAsync;\n"],"names":["createDefinedContext","context","React","createContext","undefined","c","useContext","Error","Provider","useOnMount","_i","methods","useEffect","methods_1","f","useAsync","method","options","_a","useState","response","setResponse","_b","pending","setPending","_c","success","setSuccess","_d","error","setError","_e","hasBeenCalled","setHasBeenCalled","call","useCallback","args","response_1","error_1","immediate"],"mappings":"uYAQMA,qBAAuB,WAC3B,IAAMC,EAAUC,eAAMC,mBAA6BC,GAYnD,MAAO,CAVmB,WACxB,IAAMC,EAAIH,eAAMI,WAAWL,GAC3B,QAAUG,IAANC,EACF,MAAM,IAAIE,MACR,iGAGJ,OAAOF,GAGkBJ,EAAQO,k0CCSrC,IAAMC,WAAa,eAAC,aAAAC,mBAAAA,IAAAC,kBAClB,OAAAC,gBAAU,WACR,IAAgB,QAAAC,IAAAH,WAAAA,MAASI,YACxB,KCWCC,SAAW,SACfC,EACAC,GAEM,IAAAC,EAA0BC,iBAAzBC,OAAUC,OACXC,EAAwBH,gBAAkB,GAAzCI,OAASC,OACVC,EAAwBN,gBAAkB,GAAzCO,OAASC,OACVC,EAAoBT,eAAyB,MAA5CU,OAAOC,OACRC,EAAoCZ,gBAAkB,GAArDa,OAAeC,OAEhBC,EAAOC,kBAAY,eAAO,aAAAzB,mBAAAA,IAAA0B,sIAC9BH,GAAiB,GACjBT,GAAW,GACXM,EAAS,uBAGU,iCAAMd,eAAUoB,WAGjC,OAHMC,EAAWnB,SACjBG,EAAYgB,GACZV,GAAW,MACJU,UAIP,iBAFAP,EAASQ,GACTX,GAAW,GACLW,gBAENd,GAAW,8BAEZ,IAQH,OANAf,WAAW,WACLQ,MAAAA,GAAAA,EAASsB,WACXL,eAAQjB,MAAAA,SAAAA,EAASsB,aAId,CAAEnB,WAAUG,UAASG,UAASG,QAAOK,OAAMF"}